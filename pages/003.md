# ANÁLISIS DE SISTEMAS  

# Modelo de Comportamiento  

## MINIESPECIFICACIONES  

## Introducción

Cuando comenzamos a construir el Modelo de Comportamiento de un sistema, tomamos evento por evento y dibujamos un DFD de cada uno, explicitando:

a) La entidad externa y el flujo de entrada, si es externo, o bien el flujo de control, si es temporal;  
b) Los almacenes externos que ya habíamos detectado en el Modelo Ambiental del sistema y que son accedidos por el evento, ya sean para insertar, borrar, modificar o consultar ocurrencias de los mismos;  
c) Los almacenes internos, que se corresponden a cada una de las entidades del Mapa de Información Canónico y que son accedidos por el evento, ya sean para insertar, borrar, modificar o consultar ocurrencias de los mismos;  
d) La(s) entidad(es) externa(s) y el(los) flujo(s) de salida, si es que el evento posee respuesta externa a una o más entidades.

Como resultado, si uniéramos cada uno de los DFD para formar uno solo, nos quedaría cada evento representado por una burbuja, de manera tal que no existiría conexión mediante flujos de datos con otros eventos. Es decir: los eventos sólo se comunican mediante almacenes de datos, ya sean éstos internos o externos.

Pero hasta ahora no hemos dicho nada sobre **cómo** cada evento procesará su entrada para obtener la respuesta, pudiendo ser ésta externa (flujo de salida), o bien interna (actualiza almacenes de datos), o bien ambas.

## Miniespecificación

### *¿Qué es?*

> Una miniespecificación es una descripción formal de cómo un evento, a partir de su entrada, produce su respuesta.

En otras palabras: describe la política o las reglas mediante las cuales un evento transforma su entrada en salida.

Una miniespecificación describe una burbuja de un DFD.

### *¿Qué características debería tener?*

Una miniespecificación debería ser:

- **Precisa**: para que en las etapas posteriores del Ciclo de Desarrollo de un sistema permita crear componentes del mismo que puedan probarse contra la miniespecificación.
- **Comprensible**: para que sea entendida por todos los miembros del equipo de desarrollo.
- **Sin ambigüedades**: para que diferentes personas no lleguen a diferentes interpretaciones luego de leerla.
- **Completa**: para que no quede algo sin definir.
- **No demasiado compleja**: para que pueda ser revisada con facilidad.

Respecto a la complejidad de la miniespecificación, podemos tomar como guía el no excedernos de una hoja. Si la miniespecificación de un evento excede una hoja, entonces habrá que tomar medidas para reducir la complejidad de la misma, tal como veremos en este apunte.

**Muy importante:**

> **UNA MINIESPECIFICACIÓN NO ES UN PROGRAMA.**

## Herramientas que se usan en la construcción de una miniespecificación:

Para construir una miniespecificación tenemos una serie de herramientas, las cuales se podrían clasificar en:

- **Procedurales**: lenguaje estructurado.
- **No procedurales**: precondición y postcondición.
- **Gráficas**: tablas de decisión y árboles de decisión.

## Formato que debería tener una miniespecificación:

Una miniespecificación debería tener el siguiente formato:

**Evento N - Nombre de la burbuja del DFD**
```
COMIENZO
.
.
.
FIN
```

## Notación para los elementos de datos de almacenes y/o flujos:

Si bien en el diccionario de datos cada elemento de datos tiene un nombre único que lo identifica, 
dentro de un flujo y/o almacén, en una miniespecificación puedo llegar a utilizar muchos elementos que 
tienen el mismo bombre y que pertenecen a un flujo de entrada, varios fkujos de salida y/o varios almacenes.

Para saber de cuál elemento de datos se trata, se usará la siguiente notación: 

- `flujo.elemento_de_datos`
- `almacén.elemento_de_datos`

Por supuesto, será necesario que esta notación se emplee sólo cuando sea necesario, es decir: para evitar ambigüedades en la miniespecificación.

## Lenguaje estructurado (procedural)

Construir una miniespecificación con esta herramienta procedural consiste en emplear un lenguaje 
estructurado, el cual brinda una serie de construcciones formales para estructurar la lógica de la respuesta del evento en términos de:

- Sentencias imperativas
- Decisiones
- Control
- Repetición
- Operaciones aritméticas
- Funciones predefinidas
- Definición de variables

A continuación daremos una **guía** sobre cuáles podrían ser dichas sentencias. La notación
empleada es similar a la usada en los manuales de lenguaje de programación:

- Corchetes [ ] para indicar que esa palabra es opcional dentro de la sentencia;
- Llaves {construcción 1; construcción 2; ...; construcción n } para indicar que debe optarse por una de lasvconstrucciones listadas;
- *Letra inclinada* para indicar nombre de almacenes, atributos, variables.

### *Funciones predefinidas*

- `HOY()` —  retorna la fecha actual o fecha del sistema 
- `MES(fecha)` — retorna el mes de `fecha`. Si no se indica `fecha`, asume HOY() 
- `AÑO(fecha)` — retorna el año de `fecha`. Si no se indica `fecha`, asume HOY() 
- `SEMANA-AÑO(fecha)` —  retorna el número de la semana dentro del año de `fecha`. Si no se indica `fecha`, asume HOY() 
- `SEMANA-MES(fecha)` — retorna el número de la semana dentro del mes de `fecha`. Si no se indica `fecha`, asume HOY() 
- `DIA-AÑO(fecha)` —  retorna el número de día dentro del año de `fecha`. Si no se indica `fecha`, asume HOY() 
- `DIA-MES(fecha)` — retorna el número de día dentro del mes de `fecha`. Si no se indica `fecha`, asume HOY()
- `DIA-SEMANA(fecha)` — retorna el número de día dentro de la semana de `fecha`. Si no se indica `fecha`, asume HOY()

#### Funciones para recuperación de datos:
- `SUMATORIA(elemento-dato o expresión)` — retorna la sumatoria de `elemento-dato`. Si se usa `expresión`, retorna la sumatoria del resultado de la misma. Se usa en las sentencias imperativas de recuperación de datos de almacenes 
- `CANTIDAD(ocurrencias)` — retorna la cantidad de ocurrencias encontradas. Se usa en las sentencias imperativas de recuperación de datos de almacenes 
- `MAXIMO(elemento-dato o expresión)` — retorna el valor máximo encontrado de `elemento-dato`. Si se usa `expresión`, retorna el valor máximo del resultado de la misma. Se usa en las sentencias imperativas de recuperación de datos de almacenes 
- `MINIMO(elemento-dato o expresión)` — retorna el valor mínimo encontrado de `elemento-dato`. Si se usa `expresión` retorna el valor mínimo del resultado de la misma. Se usa en las sentencias imperativas de recuperación de datos de almacenes 
- `PROMEDIO(elemento-dato o expresión)` — retorna el valor promedio de todos los `elemento-dato` encontrado. Si se usa `expresión`, retorna el valor promedio del resultado de la misma. Se usa en las sentencias imperativas de recuperación de datos de almacenes

> Nota: `expresión` es una expresión aritmética donde todos los componentes deben ser `elemento-dato`.

## Definición de variables

**Sólo cuando sea estrictamente necesario. No olvidar que una miniespecificación NO ES UN PROGRAMA.**

Una variable es una miniespecificación se nota con `v.nombre_variable`.

## Sentencias imperativas

### Para mostrar el ingreso del flujo de entrada y el egreso del flujo de salida:

- Aceptar `flujo-datos-entrada`
- Ingresar `flujo-datos-entrada`
- Mostrar `flujo-datos-salida`
- Emitir `flujo-datos-salida`

### Para mostrar la detección de un evento temporal:

- `Periodicidad ...`

**Ejemplos:**
- "Cada dos meses..."
- "Luego de 48 horas de haber ingresado a cámara de maduración..."
- "Todos los días al final de la jornada..."

### Para trabajar con almacenes de datos:

#### 1. Incorporando nuevas ocurrencias:

```
{Insertar [nueva ocurrencia]; Crear nueva ocurrencia; Incorporar nueva ocurrencia} 
con [los siguientes datos]:
  objeto 1;
  objeto 2;
  ...
[{Fin-insertar / Fin-crear / Fin-incorporar}]



Ir a [almacén] nombre-almacén y {crear nueva ocurrencia; 
insertar; incorporar nueva ocurrencia} con:
  objeto 1;
  objeto 2;
  ...
[Fin-ir]
```

#### 1.1 - Asignando el sistema automáticamente los códigos:

```
Obtener (último)elemento-dato de nombre-almacén
```

Donde:

`nombre-almacén` = nombre del almacén de datos

`objeto n` puede ser cualquiera de las siguientes construcciones:
- `elemento-dato 1` [, `elemento-dato 2`,..]. de `flujo-datos-entrada`. De esta manera estoy indicando que ese o esos elementos de datos provienen del flujo de entrada.
- `elemento-dato 1` [, `elemento-dato 2`,..]. de `flujo-datos-salida`. De esta manera estoy indicando que ese o esos elementos de datos provienen del flujo de salida (ver Ejemplo 5 del punto 4).
- `elemento-dato 1` [, `elemento-dato 2`,..]. de `nombre-almacén`. De esta manera estoy indicando que ese o esos elementos de datos provienen del un almacén de datos con el cual trabaja el evento y que fueron recuperados oportunamente mediante la sentencia correspondiente (ver punto 4).
- (último)`elemento-dato` + 1, para indicar los códigos únicos asignados por el sistema)
- `elemento-dato` = `expresión aritmética`. Si quiero expresar que en ese elemento de datos se va a guardar el resultado de la expresión aritmética. En esa expresión pueden intervenir elementos del flujo de entrada y/u otros almacenes de datos con los cuales trabaja el evento y que fueron recuperados oportunamente mediante la sentencia correspondiente (ver punto 4). Será necesario en estos casos utilizar la notación para elementos de datos y/o flujos.
- asignación de un valor a un elemento de datos.

**Ejemplo:**

Supongamos un almacén:

`SOCIOS = número socio + nombre + domicilio + teléfono + fax + e-mail + fecha nacimiento + código categoría + estado`

Y las siguientes visiones de contexto:

i - El sistema asignará un número de socio único

ii - El sistema deberá asignar el estado “activo” cuando el socio ingrese al club.

Y el siguiente DFD, correspondiente al evento: Ingresa un nuevo socio al club

*Figura 301*

siendo:

`inscripción al club = nombre + domicilio + teléfono + fax + e-mail + fecha nacimiento + código categoría`

Podríamos construir la miniespecificación para incorporar el nuevo socio de la siguiente manera:

Evento 1 - Incorporar nuevo socio

```
COMIENZO
  Aceptar inscripción al club
  Obtener (ultimo)número socio de SOCIOS
  Insertar en SOCIOS con:
    (último)número socio + 1;
    nombre, domicilio, teléfono, fax, e-mail, fecha nacimiento, código categoría de inscripción al club;
    estado = “activo”
  Fin-insertar
FIN
```

En esta miniespecificación estoy indicando que en el almacén SOCIOS se va a insertar una nueva ocurrencia donde los datos:
- son asignados por el sistema : como número de socio (automáticamente) y estado (según visión de contexto ii) 
- provienen del flujo inscripción al club

#### 2. Actualizando ocurrencias existentes:

```
{Actualizar ; Modificar ; Cambiar} [ocurrencia en] nombre-almacén con [los siguientes datos]:
  objeto 1;
  objeto 2;
  ...
  donde condición 1 [{y ; o} condición 2 [...]]
[{Fin-actualizar ; Fin-modificar ; Fin-cambiar}]


Ir a [almacén] nombre-almacén y {actualizar ; modificar ; cambiar} [ocurrencia] [con los siguientes datos]:
  objeto 1 ;
  objeto 2 ;
  ...
  donde condición 1 [{y ; o} condición 2 [...]]
[Fin-ir]
```

**Donde:**

`condición` me va a permitir indicar cuál ocurrencia o cuales ocurrencias se deberán actualizar. Y se construye indicando para cada elemento de datos del almacén por el cual se deberá buscar 
la ocurrencia: `elemento-dato` `operador-booleano` `criterio`, siendo:

- `operador-booleano`: =, >, <, <>, >=, <=, entre (`elemento-dato`, `elemento-dato`), corresponda
- `criterio`: {elemento-dato ; valor determinado ; expresión aritmética}

**Ejemplo de condiciones:**

1) número socio = novedades socio.número socio (siendo novedades socio un flujo de entrada)
2) saldo >= solicitud informe.saldo (siendo solicitud informe un flujo de entrada)
3) pedido estadistica.fecha desde <= fecha solicitud <= pedido estadística.fecha hasta (siendo pedido estadística un flujo de entrada). Esta condición también podría haberse escrito: fecha solicitud entre (pedido estadística.fecha desde, pedido estadística, fecha hasta)
4) estado <> “activo”
5) código categoría = CATEGORÍAS.código categoría (siendo CATEGORÍAS un almacén de datos)
6) fecha factura > HOY() - 5 meses
7) fecha factura corresponda a MES() 
8) fecha remito corresponda a AÑO() - 3

**Observaciones respecto a las condiciones:**
Ante anidamientos de condiciones muy completos por el uso de `y` y/u `o` en la sintaxis, podrán emplearse paréntesis para mayor claridad y/o para alterar el orden de precedencia de la `y`, `o`.

**Ejemplo 1:**

Supongamos el siguiente almacén

`ARTICULOS = código artículo + descripción + código rubro + precio costo + margen ganancia + punto pedido + estado`

La siguiente visión de contexto :
i - el sistema colocará al artículo como “inhabilitado” cuando se lo quiera inhabilitar en forma individual o por rubro.

Y el siguiente DFD correspondiente al evento : Se ha decidido inhabilitar artículos de un rubro.

*Figura 302*

siendo: 

`inhabilitación por rubro = código rubro`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 18 - Inhabilitar artículos del rubro
```
COMIENZO
  Aceptar inhabilitación por rubro
  Actualizar ARTÍCULOS con:
    estado = “inhabilitado”
    donde código rubro = inhabilitación artículo.código rubro y estado = “habilitado”
  Fin-actualizar
FIN
```
En esta miniespecificación estoy indicando que, para todos los artículos que pertenezcan al código de rubro del flujo de entrada y no hayan sido previamente inhabilitado (ver visión de contexto), se modifique su estado. Estoy modificando muchas ocurrencias.

**Ejemplo 2:**

Supongamos un almacén

`SOCIOS = número socio + nombre + domicilio + teléfono + fax + e-mail + fecha nacimiento + código categoría + estado
`

Y el siguiente DFD, correspondiente al evento: Se producen novedades en los datos del socio

*Figura 303*

siendo:

`novedades socio = número socio + (nombre) + (domicilio) + (teléfono) + (fax) + (e-mail) + (fecha nacimiento)`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 5 - Actualizar novedades del socio
```
COMIENZO
  Aceptar novedades socio
  Actualizar SOCIOS con:
    nombre, domicilio, teléfono, fax, e-mail, fecha nacimiento de novedades socio
    donde número socio = novedades socio.número socio
  Fin-actualizar
FIN
```

En esta miniespecificación estoy actualizando los datos de un socio determinado. Estoy modificando una sola ocurrencia.

#### 3. Borrando ocurrencias existentes:

```
{Borrar ; Eliminar ; Dar de baja ; Suprimir ; Quitar} [ocurrencia] en nombre-almacén 1 [, nombrealmacén 2 [, ...] 
  donde condición 1 [{y ; o} condición 2 [...]]
[Fin-borrar]

Ir a nombre-almacén 1 [, nombre-almacén 2 [, ...] y {borrar ; eliminar ; dar de baja ; suprimir ;
quitar} [ocurrencia]
  donde condición 1 [{y ; o} condición 2 [...]]
[Fin-ir]
```

**Ejemplo:**
Supongamos los siguientes almacenes:

`PRESUPUESTOS = número presupuesto + fecha presupuesto + número cliente + fecha vencimiento + estado`

`DETALLES PRESUPUESTO = número presupuesto + código artículo + cantidad + precio presupuestado`

`CONDICIONES PRESUPUESTO = número presupuesto + cantidad días + interés presupuesto`

Donde:

`interés presupuesto = `
- puede tomar valores nulos, negativos y positivos;
- si es negativo significa un descuento sobre el precio presupuestado;
- si es positivo significa un recargo sobre el precio presupuestado;

Y el siguiente DFD del evento: Cada dos meses, eliminar todos aquellos presupuestos con estado “pendiente”

*Figura 304*

Podríamos construir la miniespecificación de la siguiente manera:

Evento 15 - Eliminar presupuestos pendientes:
```
COMIENZO
  Cada dos meses ...
  Borrar en PRESUPUESTOS, DETALLES PRESUPUESTO y CONDICIONES PRESUPUESTO
    donde estado = “pendiente” y
      DETALLES PRESUPUESTO = PRESUPUESTOS.número presupuesto y
      CONDICIONES PRESUPUESTOS.número presupuesto = PRESUPUESTOS.número
      presupuesto
  Fin-borrar
FIN
```
En esta miniespecificación, el evento eliminará de PRESUPUESTOS todas las ocurrencias con estado = “pendiente”, pero además, deberá eliminar las ocurrencias relacionadas de los almacenes que definen un presupuesto (DETALLES PRESUPUESTOS y CONDICIONES PRESUPUESTOS), ya que de lo contrario, quedarían serias inconsistencias en el Modelo de Datos. Esto puede hacerse fácilmente con una sola sentencia de lenguaje estructurado, tal como se podría hacer con SQL, si se implementara en Bases de Datos Relacionales.

#### 4. Recuperando datos de ocurrencias existentes:

```
Nombre-sentencia datos-a-recuperar-1 [, datos-a-recuperar-2 [,...]]
  [para incluir en flujo-salida]
  donde condición 1 [{y ; o} condición 2 [...]]
  [{por cada grupo de ; por cada corte de} elemento-dato 1 [, elemento-dato 2 [,...], hacer:
    sentencia-lenguaje-estructurado, ...
  {Fin-cada-grupo ; Fin-cada-corte}] *sólo si se indicó por cada grupo o por cada corte en datos-a-recuperar-n*
[Fin-sentencia]

Ir a nombre-almacén 1 y Nombre-sentencia datos-a-recuperar-1 [, datos-a-recuperar-2 [,...]]
  [para incluir en flujo-salida]
  donde condición 1 [{y ; o} condición 2 [...]]
  [{por cada grupo de ; por cada corte de} elemento-dato 1 [, elemento-dato 2 [,...], hacer:
    sentencia-lenguaje-estructurado, ...
  {Fin-cada-grupo ; Fin-cada-corte}] *sólo si se indicó por cada grupo o por cada corte en datos-a-recuperar-n*
[Fin-ir]
```

Donde:

`Nombre-sentencia = {Seleccionar ; Buscar ; Recuperar}`

`datos-a-recuperar-n = {{todos los elementos ; ocurrencia completa ; *} ; objeto-r 1 [, objeto-r 2 [,...]]} de nombre-almacén 1 [ordenado por elemento-dato 1 [, elemento-dato 2 [,...]] [{agrupado por ; con corte por} elemento-dato 1 [, elemento-dato 2 [,...]]`

`Fin-sentencia = {Fin-seleccionar ; Fin-buscar ; Fin-recuperar}`

`sentencia-lenguaje-estructurado = cualquier sentencia válida de lenguaje estructurado objeto-r puede ser:`
- elemento-dato que se desea recuperar
- expresión aritmética. En este caso, cada uno de sus componentes pueden ser un elemento-dato o bien un valor constante, pero al menos uno de ellos debe ser un elemento-dato.

`flujo-salida` es el nombre del flujo de datos de salida que contendrá los datos tal cual salen del almacén.

**Ejemplo 1:**

Supongamos los siguientes almacenes:

`PRESUPUESTOS = número presupuesto + fecha presupuesto + número cliente + fecha vencimiento + estado`

`DETALLES PRESUPUESTO = número presupuesto + código artículo + cantidad + precio presupuestado`

`CONDICIONES PRESUPUESTO = número presupuesto + cantidad días + interés presupuesto`

`CLIENTES = número cliente + nombre completo + domicilio completo + situación tributaria + CUIT`

Donde:

`interés presupuesto = `
- puede tomar valores nulos, negativos y positivos;
- si es negativo significa un descuento sobre el precio presupuestado
- si es positivo significa un recargo sobre el precio presu

Y el siguiente DFD del evento: Se desea consultar un presupuesto

*Figura 305*

donde:

`presupuesto a consultar = número presupuesto`

`presupuesto consultado = número presupuesto + fecha presupuesto + fecha vencimiento + número cliente + nombre completo + domicilio completo + situación tributaria + CUIT + estado + 1{código artículo + cantidad + precio presupuestado}n + 1{cantidad días + interés presupuesto}4`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 10 - Mostrar datos del presupuesto
```
COMIENZO
  Aceptar presupuesto a consultar
  Seleccionar todos los elementos de PRESUPUESTOS
    donde número presupuesto = presupuesto a consultar.número presupuesto
    para incluir en presupuesto consultado
  Fin-seleccionar
  Seleccionar código artículo, cantidad, precio presupuestado de DETALLES PRESUPUESTO
    donde número presupuesto = presupuesto a consultar.número presupuesto
    para incluir en presupuesto consultado
  Fin-seleccionar
  Seleccionar cantidad días, interés presupuesto de CONDICIONES PRESUPUESTO
    donde número presupuesto = presupuesto a consultar.número presupuesto
    para incluir en presupuesto consultado
  Fin-seleccionar
  Seleccionar nombre completo, domicilio completo, situación tributaria, CUIT de CLIENTES
    donde número cliente = PRESUPUESTOS.número cliente
    para incluir en presupuesto consultado
  Fin-seleccionar
  Mostrar presupuesto consultado
FIN
```

O bien, como todos los seleccionar tienen idéntica condición:

Evento 10 - Mostrar datos del presupuesto
```
COMIENZO
  Aceptar presupuesto a consultar
  Seleccionar todos los elementos de PRESUPUESTOS,
      código artículo, cantidad, precio presupuestado de DETALLES PRESUPUESTO, 
      cantidad días, interés presupuesto de CONDICIONES PRESUPUESTO
    donde PRESUPUESTOS.número presupuesto = presupuesto a consultar.número presupuesto y
      DETALLES PRESUPUESTO. número presupuesto = presupuesto a consultar.número presupuesto y
      CONDICIONES PRESUPUESTO.número presupuesto = presupuesto a consultar.número presupuesto
    para incluir en presupuesto consultado
  Fin-seleccionar
  Seleccionar nombre completo, domicilio completo, situación tributaria, CUIT de CLIENTES
    donde número cliente = PRESUPUESTOS.número cliente
    para incluir en presupuesto consultado
  Fin-seleccionar
  Mostrar presupuesto consultado
FIN
```

**Observaciones:**

Estas sentencias de recuperación de datos pueden tener como resultado una sola ocurrencia (como en el ejemplo 1) o bien un conjunto de ellas, todo depende de cómo se hayan redactado las condiciones.

En el caso de que se recuperen varias ocurrencias y deba hacerse manipulaciones adicionarles con cada una de ellas, las sentencias para ello se deben incluir antes del Fin-..., ya que en este caso, estas sentencias de recuperación de datos establecen un bucle. Esto se muestra en el siguiente ejemplo.

**Ejemplo 2:**

Supongamos los mismos almacenes que para el ejemplo 1, y el siguiente DFD del evento: Se desean consultar los presupuestos pendientes

*Figura 306*

donde

`presupuestos pendientes = {}`

`presupuestos pendientes consultados = número presupuesto + fecha presupuesto + fecha vencimiento + número cliente + nombre completo + domicilio completo + situación tributaria + CUIT + 1{código artículo + cantidad + precio presupuestado}n + 1{cantidad días + interés presupuesto}4`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 11 - Mostrar presupuestos pendientes
```
COMIENZO
  Seleccionar número presupuesto, fecha presupuesto, número cliente, fecha vencimiento de PRESUPUESTOS
    donde estado = “pendiente”
    para incluir en presupuestos pendientes consultados
    Seleccionar nombre completo, domicilio completo, situación tributaria, CUIT de CLIENTES
      donde número cliente = PRESUPUESTOS.número cliente
      para incluir en presupuestos pendientes consultados
    Fin-seleccionar
  Fin-seleccionar
  Seleccionar código artículo, cantidad, precio presupuestado de DETALLES PRESUPUESTO
    donde número presupuesto = PRESUPUESTOS.número presupuesto
    para incluir en presupuestos pendientes consultados
  Fin-seleccionar
  Seleccionar cantidad días, interés presupuesto de CONDICIONES PRESUPUESTO
    donde número presupuesto = PRESUPUESTOS.número presupuesto
    para incluir en presupuestos pendientes consultados
  Fin-seleccionar
  Mostrar presupuestos pendientes consultados
FIN
```

O bien, como tengo dos seleccionar con idéntica condición:

Evento 11 - Mostrar presupuestos pendientes
```
COMIENZO
  Seleccionar número presupuesto, fecha presupuesto, número cliente, fecha vencimiento de PRESUPUESTOS
    donde estado = “pendiente”
    para incluir en presupuestos pendientes consultados
    Seleccionar nombre completo, domicilio completo, situación tributaria, CUIT de CLIENTES
      donde número cliente = PRESUPUESTOS.número cliente
      para incluir en presupuestos pendientes consultados
    Fin-seleccionar
  Fin-seleccionar
  Seleccionar código artículo, cantidad, precio presupuestado de DETALLES PRESUPUESTO, cantidad días, interés presupuesto de CONDICIONES PRESUPUESTO
    donde DETALLES PRESUPUESTO.número presupuesto = PRESUPUESTOS.número
    presupuesto y 
    CONDICIONES PRESUPUESTO.número presupuesto = PRESUPUESTOS.número presupuesto
    para incluir en presupuestos pendientes consultados
  Fin-seleccionar
  Mostrar presupuestos pendientes consultados
FIN
```

**Ejemplo 3:**

Supongamos los mismos almacenes del Ejemplo 1 y el siguiente DFD para el evento: Se desea obtener estadística de presupuestos aceptados

*Figura 307*

donde:

`rango de meses = mes desde + mes hasta`

`estadística presupuesto = mes desde + mes hasta + 1{mes + total del mes}n`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 25 - Mostrar estadística presupuestos
```
COMIENZO
  Aceptar rango de meses
  v.total del mes = 0
  Seleccionar número presupuesto de PRESUPUESTOS
    donde fecha presupuesto corresponda entre (mes desde, mes hasta) y estado = “aceptado”
    ordenado por MES(fecha presupuesto), con corte por MES(fecha presupuesto)
    Seleccionar SUMATORIA(precio presupuesto) de DETALLES PRESUPUESTO
      donde número presupuesto = PRESUPUESTOS.número presupuesto
      v.total del mes = v.total del mes + SUMATORIA(precio presupuesto)
    Fin-seleccionar
    Por cada corte de MES(fecha presupuesto), hacer:
      estadística presupuesto.mes = MES(fecha presupuesto)
      estadística presupuesto.total del mes = v.total del mes
      v.total del mes = 0
    Fin-cada-corte
  Fin-seleccionar
  estadística presupuesto.mes desde = rango de meses.mes desde
  estadística presupuesto.mes hasta = rango de meses.mes hasta
  Mostrar estadística presupuesto
FIN
```

**Ejemplo 4:**

Supongamos los siguientes almacenes:

`CTA. CTE. PROVEEDORES = número proveedor + fecha movimiento + código comprobante + número comprobante + importe débito + importe crédito`

`PROVEEDORES = número proveedor + nombre completo + domicilio completo + situación tributaria + CUITA + contacto comercial`

Y el siguiente DFD del evento: Se desea conocer el saldo de la cuenta corriente de un proveedor

*Figura 308*

donde:

`proveedor = número proveedor`

`saldo cuenta corriente = número proveedor + nombre completo + domicilio completo + saldo + cantidad movimientos + menor fecha en cta.cte`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 8 - Obtener saldo del proveedor
```
COMIENZO
  Aceptar proveedor
  Seleccionar número proveedor, nombre completo, domicilio completo de PROVEEDORES
    donde número proveedor = proveedor.número proveedor
    para incluir en saldo cuenta corriente
  Fin-seleccionar
  Seleccionar CANTIDAD(ocurrencias), MINIMA(fecha movimiento), SUMATORIA(importe crédito - importe débito) de CTA.CTE.PROVEEDORES
    donde número proveedor = proveedor.número proveedor
    para incluir en saldo cuenta corriente
  Fin-seleccionar
FIN
```

**Ejemplo 5:**

Supongamos los siguientes almacenes

`REMITOS = número remito + fecha remito + número cliente + estado remito`

`DETALLES REMITO = número remito + código artículo + cantidad + estado artículo remito`

`FACTURAS = número factura + fecha factura + fecha vencimiento + número remito + número cliente + % IVA + estado factura`

`DETALLES FACTURA = número factura + código artículo + cantidad + precio unitario`

`ARTÍCULOS = código artículo + descripción + código rubro + precio costo + margen ganancia + precio venta`

`CLIENTES = número cliente + nombre completo + domicilio completo + situación tributaria + CUIT`

`IVA = % IVA`

Y el siguiente fragmento de la narrativa:

Todos los días, al inicio de la jornada, será necesario generar las facturas para aquellos remitos cuyo estado sea “entregado”. Para ello será necesario tener en cuenta cuáles artículos fueron entregados y cuáles devueltos. A cada remito procesado le cambiará el estado a “facturado” y a las facturas generadas, el estado será “pendiente”. Las facturas deberán ser entregadas a Administración.

Y la siguiente versión de contexto:

i - La empresa sólo mantiene relaciones comerciales con clientes inscriptos en IVA.
ii - Todas las facturan vencen a los 30 días de la fecha de la misma.

Y el siguiente DFD que corresponde al evento: Todos los días, al inicio de la jornada, generar facturas

*Figura 309*

donde:

`facturas a entregar = 1{ número factura + fecha factura + fecha vencimiento + número remito + número cliente + nombre completo + domicilio completo + situación tributaria + CUIT + 1{código artículo + descripción + cantidad + precio unitario + precio total}n + subtotal factura + % IVA + total factura}n`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 45 - Facturar remitos entregados

```
COMIENZO
  Todos los días, al inicio de la jornada ...
  Seleccionar número remito, número cliente de REMITOS
    donde estado remito = “entregado”
    para incluir en facturas a entregar
    Seleccionar nombre completo, domicilio completo, situación tributaria, CUIT de CLIENTES
      donde número cliente = REMITOS.número cliente
      para incluir en facturas a entregar
    Fin-seleccionar
    Seleccionar % IVA de IVA
      para incluir en facturas a entregar
    Fin-seleccionar
    Seleccionar código artículo, cantidad de DETALLES REMITOS
      donde número remito = REMITOS.número remito y estado artículo remito = “entregado”
      para incluir en facturas a entregar
      Seleccionar descripción, precio venta de ARTÍCULOS
        donde código artículo = DETALLES REMITO.código artículo
        para incluir en facturas a entregar
        facturas a entregar.precio total = ARTÍCULOS.precio venta * DETALLES REMITO.cantidad
      Fin-seleccionar
    Fin-seleccionar
    facturas a entregar.fecha factura = HOY()
    facturas a entregar.fecha vencimiento = HOY() + 30 días
    facturas a entregar.subtotal factura = (símbolo sumatoria) facturas a entregar.precio total
    facturas a entregar.subtotal factura = (facturas a entregar.subtotal factura * % IVA) / 100
    Obtener (último)número factura de FACTURAS
    Insertar en FACTURAS con (último)número factura + 1 ; fecha factura, fecha vencimiento,
    número remito, número cliente, % IVA de facturas a entregar ; estado factura = “pendiente”
    Fin-insertar
    Insertar en DETALLES FACTURA con (último)número factura + 1 ; código artículo, cantidad, precio unitario de facturas a entregar
    Fin-insertar
    Actualizar REMITOS con estado remito = “facturado”
      donde número remito = facturas a entregar.número remito
    Fin-actualizar
  Fin-seleccionar
  Mostrar facturas a entregar
FIN
```

#### 5. Validando existencia de una ocurrencia en un almacén:

```
{Verificar si {existe ; no existe} ; Validar {existencia ; no existencia} de} [ocurrencia] en nombre-almacén
  donde condición
  [En caso de existir
    sentencia-lenguaje-estructurado, ...]
  [En caso de no existir
    sentencia-lenguaje-estructurado, ...]
[{Fin-verificar ; Fin-validar}]

{Verificar que ; Validar que}{existe ; no existe} elemento-dato [ + elemento-dato [+ ,,,] en nombre-almacén
  [En caso de existir
    sentencia-lenguaje-estructurado, ...]
  [En caso de no existir
    sentencia-lenguaje-estructurado, ...]
[{Fin-verificar ; Fin-validar}]
```

**Donde:**

En la último sentencia, `elemento-dato [ + elemento-dato [+ ,,,]` son los atributos clave de `nombre almacén`

### *Sentencias de decisión:*

**Decisión simple:**

Una decisión es simple cuando tiene dos posibilidades.

```
Si condición, entonces:
  sentencia-lenguaje-estructurado, ...
sino:
  sentencia-lenguaje-estructurado, ...
Fin-si
```

Donde:

condición también puede incluir:
- `{existe ; no existe} elemento-dato` en `flujo-datos-entrada`
- `{existe ; no existe}` ocurrencia en `nombre-almacén`

**Decisión múltiple:**

Si una decisión tiene más de dos posibilidades, entonces es múltiple y plantearla con una construcción Si, entonces, sino no resultaría tan fácil.

```
Hacer según caso:
  caso 1
    sentencia-lenguaje-estructurado, ...
  caso 2
    sentencia-lenguaje-estructurado, ...
  ...
  caso n
    sentencia-lenguaje-estructurado
  de otro modo
    sentencia-lenguaje-estructurado
Fin-hacer-según
```

Donde:

caso n puede ser:
- condición
- `{existe ; no existe} elemento-dato` en `flujo-datos-entrada`
- `{existe ; no existe}` ocurrencia en `nombre-almacén`

**Ejemplo 1:**

Supongamos los siguientes almacenes:

`ALUMNOS = número legajo + nombre + tipo documento + número documento + fecha nacimiento + sexo + nacionalidad + domicilio + código carrera + fecha inscripción`

`CARRERAS = código carrera + nombre carrera`

`MATERIAS = código materia + nombre materia + año cursado + horas semanales + código materia`

`MATERIAS POR ALUMNO = número legajo + código materia + fecha inscripción + estado`

Donde:

`estado = “libre”, “regular”`

Y el siguiente DFD que corresponde al evento: Alumno consulta las materias regulares que posee de un determinado año.

Donde:

`materias a consultar = [número legajo | tipo documento + número documento] + año cursado`

`materias regulares = número legajo + nombre + tipo documento + número documento + código carrera + nombre carrera + año cursado + 0{código materia + nombre materia}n`

*Figura 310*

Podríamos construir la miniespecificación de la siguiente manera:

```
COMIENZO
  Aceptar materias a consultar
  Si existe número legajo en materias a consultar, entonces:
    Seleccionar número legajo, nombre, tipo documento, número documento, código carrera de ALUMNOS
      donde número legajo = materias a consultar.número legajo
      para incluir en materias regulares
    Fin-seleccionar
  Sino
    Seleccionar número legajo, nombre, tipo documento, número documento, código carrera de ALUMNOS
      donde tipo documento = materias a consultar.tipo documento y número documento = materias a consultar.número documento
      para incluir en materias regulares
    Fin-seleccionar
  Fin-si
  Seleccionar código carrera, nombre carrera de CARRERAS
    donde código carrera = ALUMNOS.código carrera
    para incluir en materias regulares
  Fin-seleccionar
  Seleccionar código materia MATERIAS POR ALUMNO, nombre materia, año cursado de MATERIAS
    donde MATERIAS POR ALUMNO.número legajo = ALUMNOS.número legajo y
          MATERIAS POR ALUMNO.estado = “regular” y
          MATERIAS.código materia = MATERIAS POR ALUMNO.código materia y
          MATERIAS.año cursado = materias a consultar.año cursado
    para incluir en materias regulares
  Fin-seleccionar
  Mostrar materias regulares
FIN
```

**Ejemplo 2:**

Supongamos los siguientes almacenes:

`VENDEDORES = número vendedor + nombre vendedor + domicilio + zona venta`

`ZONAS = zona venta + nombre zona + localidad cabecera`

`CLIENTES = número cliente + nombre cliente + domicilio + zona venta`

`FACTURAS = número factura + fecha + número cliente + estado`

`DETALLE FACTURAS = número factura + código producto + cantidad + precio unitario`

Donde:

`estado = “pendiente”, “facturada”, “anulada”`

La siguiente visión de contexto:

El rendimiento mensual de un vendedor tomará en cuenta el volumen de ventas como los totales de las facturas no anuladas y se considerará:
- muy bueno, si el volumen de ventas excede los $10000 (sin incluir)
- bueno, si el volumen de ventas se encuentra entre los $5001 (inclusive) y los $10000 (inclusive)
- regular, si el volumen de ventas se encuentra entre los $2001 (inclusive) y los $ 5000 (inclusive)
- malo, si el volumen ventas es inferior a $2000 (inclusive)

Y el siguiente DFD correspondiente al evento: Gerente desea evaluar a los vendedores

*Figura 311*

Donde:

`mes a evaluar = mes + año`

`rendimiento vendedores = mes + año + 1{número vendedor + nombre vendedor + zona venta + nombre zona + cantidad clientes + volumen ventas + rendimiento}n`

`rendimiento = “malo”, “regular”, “bueno”, “muy bueno”`

La miniespecificación podría llegar a construirse de la siguiente manera:

Evento 29 – Obtener rendimiento
```
COMIENZO
  Aceptar mes a evaluar
  Seleccionar número vendedor, nombre vendedor, zona venta de VENDEDORES
    para incluir en rendimiento vendedores
    Seleccionar nombre zona de ZONAS
      donde zona venta = VENDEDORES.zona venta
      para incluir en rendimiento vendedores
    Fin-seleccionar
    Seleccionar CONTADOR(ocurrencias) de CLIENTES
      donde zona venta = VENDEDORES.zona venta
      para incluir en rendimiento vendedores
    Fin-seleccionar
    Seleccionar SUMATORIA(cantidad * precio unitario) de DETALLE FACTURAS
      donde DETALLE FACTURAS.número factura = FACTURAS.número factura y
          MES(FACTURAS.fecha) = mes a evaluar.mes y
          AÑO(FACTURAS.fecha) = mes a evaluar.año y
          FACTURAS.número cliente = CLIENTES.número cliente y
          CLIENTES.zona venta = VENDEDORES.zona venta
      para incluir en rendimientos vendedores
    Fin-seleccionar
    Hacer según caso:
      SUMATORIA (cantidad * precio unitario) > 10000
        rendimiento = “muy bueno”
      SUMATORIA (cantidad * precio unitario) entre (5001 y 10000)
        rendimiento = “bueno”
      SUMATORIA (cantidad * precio unitario) entre (2001 y 5000)
        rendimiento = “regular”
      SUMATORIA (cantidad * precio unitario) <= 2000
        rendimiento = “malo”
    Fin-hacer-según
  Fin-seleccionar
  rendimiento vendedores.mes = mes a evaluar.mes
  rendimiento vendedores.año = mes a evaluar.año
  Mostrar rendimiento vendedores
FIN
```

**Observaciones:**

La siguiente sentencia,

```
Seleccionar SUMATORIA(cantidad * precio unitario) de DETALLE FACTURAS
  donde DETALLE FACTURAS.número factura = FACTURAS.número factura y
    FACTURAS.estado <> “anulada” y
    MES(FACTURAS.fecha) = mes a evaluar.mes y
    AÑO(FACTURAS.fecha) = mes a evaluar.año y
    FACTURAS.número cliente = CLIENTES.número cliente y
    CLIENTES.zona venta = VENDEDORES.zona venta
  para incluir en rendimientos vendedores
Fin-seleccionar
```

No hace otra cosa más que calcular el total (SUMATORIA(cantidad * precio unitario) de DETALLE FACTURAS) de todas las facturas que no estén anuladas (FACTURAS.estado <> “anulada”); cuya fecha corresponda al mes y año ingresado (MES(FACTURAS.fecha) = mes a evaluar.mes y AÑO(FACTURAS.fecha) = mes a evaluar.año) y que además sea de un cliente (FACTURAS.número cliente = CLIENTES.número cliente) del vendedor (CLIENTES.zona venta = VENDEDORES.zona venta) cuyo rendimiento se desea obtener.

### *Sentencias de repetición:*

```
Mientras condición, hacer:
  sentencia-lenguaje-estructurado, ...
  ...
[Fin-mientras]

Para cada {elemento-dato; condición}, hacer:
  sentencia-lenguaje-estructurado, ...
  ...
[Fin-para-cada]

Repetir hasta condición:
  sentencia-lenguaje-estructurado, ...
  ...
[Fin-repetir]
```

Observaciones:

Si en las sentencias para trabajar con ocurrencias de almacenes no deseáramos utilizar la propiedad de bucle o repetición, se podrían emplear estas sentencias.

**Ejemplo:**

Supongamos los siguientes almacenes:

`CLIENTES = número cliente + nombre + domicilio completo + situación tributaria + CUIT`

`PRODUCTOS = código producto + descripción + precio venta`

`REMITOS = número remito + fecha remito + número cliente + estado`

`DETALLE REMITOS = número remito + código producto + cantidad`

Donde:

`estado = “pendiente”, “entregado”, “facturado”`

Las siguientes visiones de contexto:

- Los productos solicitados por los clientes se le entregarán siempre a su domicilio con remito, llegando luego la factura por medio del viajante.
- El sistema asignará a cada remito, el estado “pendiente” cuando se confeccionen; “entregado”, cuando Transporte lo notifique y “facturado” cuando se confeccione la factura por el mismo.

Y el siguiente DFD que corresponde al evento: Cliente solicita productos

`pedido = número cliente + 1{código producto + cantidad}n`

`remito a entregar = número remito + fecha remito + número cliente + nombre + domicilio completo + situación tributaria + CUIT + 1{código producto + descripción + cantidad}n`

*Figura 312*

La miniespecificación podría construirse de la siguiente manera:

Evento 9 – Generar remito
```
COMIENZO
  Aceptar pedido
  Seleccionar número cliente, nombre, domicilio completo, situación tributaria, CUIT de CLIENTES
    donde número cliente = pedido.número cliente
    para incluir en remito a entregar
  Fin-seleccionar
  Obtener (último)número remito de REMITOS
  Insertar en REMITOS con (último)número remito + 1; HOY(); número cliente de pedido; estado = “pendiente”
  Fin-insertar
  Para cada pedido.código producto, hacer:
    Insertar en DETALLE REMITOS con (último)número remito + 1; código producto y cantidad de pedido
    Fin-insertar
    Seleccionar código producto, descripción de PRODUCTOS
      donde código producto = pedido.código producto
      para incluir en remito a entregar
    Fin-seleccionar
  Fin-para
  Mostrar remito a entregar
FIN
```

O bien, podría haberse hecho:

Evento 9 – Generar remito

```
COMIENZO
  Aceptar pedido
  Seleccionar número cliente, nombre, domicilio completo, situación tributaria, CUIT de CLIENTES
    donde número cliente = pedido.número cliente
    para incluir en remito a entregar
  Fin-seleccionar
  Obtener (último)número remito de REMITOS
  Insertar en REMITOS con (último)número remito + 1; HOY(); número cliente de pedido; estado = “pendiente”
  Fin-insertar
  Mientras exista código producto en pedido, hacer:
    Insertar en DETALLE REMITOS con (último)número remito + 1; código producto y cantidad de pedido
    Fin-insertar
    Seleccionar código producto, descripción de PRODUCTOS
      donde código producto = pedido.código producto
      para incluir en remito a entregar
    Fin-seleccionar
  Fin-mientras
  Mostrar remito a entregar
FIN
```

O bien: 

Evento 9 – Generar remito
```
COMIENZO
  Aceptar pedido
  Seleccionar número cliente, nombre, domicilio completo, situación tributaria, CUIT de CLIENTES
    donde número cliente = pedido.número cliente
    para incluir en remito a entregar
  Fin-seleccionar
  Obtener (último)número remito de REMITOS
  Insertar en REMITOS con (último)número remito + 1; HOY(); número cliente de pedido; estado = “pendiente”
  Fin-insertar
  Repetir hasta que se terminen código producto en pedido:
    Insertar en DETALLE REMITOS con (último)número remito + 1; código producto y cantidad de pedido
    Fin-insertar
    Seleccionar código producto, descripción de PRODUCTOS
      donde código producto = pedido.código producto
      para incluir en remito a entregar
    Fin-seleccionar
  Fin-repetir
  Mostrar remito a entregar
FIN
```

### *Sentencias de control:*

`salir`

`continuar`

Estas sentencias suelen emplearse en sentencias de decisión (tanto simples como compuestas), incluso cuando estas sentencias de decisión se encuentran dentro de alguna sentencia de repetición.

Para ilustrar el uso de estas sentencias, veremos algunos ejemplos de formato.

**Ejemplo 1:**
Evento n – Nombre burbuja
```
COMIENZO
  ...
  ...
  ...
  Si condición, entonces:
    ...
    salir
  sino
    sentencia-lenguaje-estructurado
    ...
  Fin-si
  ...
  ...
FIN
```
La sentencia salir forzaría el fin de la miniespecificación.

**Ejemplo 2:**
Evento n – Nombre burbuja
```
COMIENZO
  ...
  ...
  ...
  Si condición, entonces:
    continuar
  sino
    sentencia-lenguaje-estructurado
    ...
  Fin-si
  ...
  ...
FIN
```
La sentencia continuar implica seguir con la sentencia siguiente al Si-sino-Fin-si.

**Ejemplo 3:**
Evento n – Nombre burbuja
```
COMIENZO
  ...
  ...
  ...
  Para cada elemento-dato, hacer:
    ...
    Si condición, entonces:
      ...
      salir
    sino
      sentencia-lenguaje-estructurado
      ...
    Fin-si
  Fin-para
  ...
  ...
FIN
```
La sentencia salir obligaría a finalizar el bucle de repetición impuesto por la sentencia Para cada.

**Ejemplo 4:**
Evento n – Nombre burbuja
```
COMIENZO
  ...
  ...
  ...
  Mientras condición, hacer:
    ...
    Si condición, entonces:
      ...
      continuar
    sino
      sentencia-lenguaje-estructurado
      ...
    Fin-si
  ...
  Fin-mientras
  ...
FIN
```
La sentencia continuar volvería a desencadenar una nueva iteración o nuevo bucle de la sentencia Mientras.

### *Operaciones aritméticas:*

Muchas veces es necesario emplear expresiones aritméticas para explicitar la forma en que se calcula un determinado elemento de dato.

En este caso podemos recurrir a expresar:

Mediante palabras: 
- Sumar
- Restar
- Dividir
- Multiplicar
- Obtener
- Calcular

**Ejemplos:**
1) Obtener la raíz cuadrada de indicadores.índice principal para incluir en resultados (siendo indicadores un flujo de entrada y resultados un flujo de salida)
2) Calcular resultado.primer raíz como la raíz cuadrada de indicadores.índice principal (siendo indicadores un flujo de entrada y resultados un flujo de salida)
3) Calcular factura.total factura como la sumatoria de (DETALLE FACTURAS.precio unitario * DETALLE FACTURAS.cantidad) (siendo factura un flujo de salida)
4) Calcular factura.subtotal factura aplicando DESCUENTOS.porcentaje sobre factura.total factura.
5) Sumar MOVIMIENTOS.importe movimiento a totales.total movimiento (siendo totales un flujo de salida)
6) Multiplicar cantidad por índice para incluir en resultados (siendo resultados un flujo de salida)
7) Dividir v.total ventas por v.total facturas para incluir en estadística.relación ventas (siendo v.total ventas y v.total.facturas variables y estadística un flujo de salida)

El uso de palabras para expresiones aritméticas debe usarse siempre y cuando la expresión resultante se entienda.

Mediante símbolos aritméticos:

- Suma +
- Resta -
- Producto *
- División /
- Porcentaje %
- Exponenciación ** 
- Símbolo de la raíz cuadrada √
- Sumatoria ∑ 
- Productoria ∏
- Símbolo de una integral ∫
- etc.

**Ejemplos:**

1) resultados.primer raíz = √indicadores.índice principal
2) factura.total factura = ∑ (DETALLE FACTURAS.precio unitario * DETALLE FACTURAS.cantidad)
3) factura.subtotal factura = (factura.total factura * DESCUENTOS.porcentaje) / 100
4) totales.total movimiento = totales.total movimiento + MOVIMIENTOS.importe
5) resultado.indicador = cantidad * índice
6) estadística.relación ventas = v.total ventas / v.total facturas

Mediante el diccionario de datos:

Si cuando construimos el diccionario de datos de elementos continuos indicamos la forma de cálculo, entonces ahorraríamos palabras en las miniespecificaciones.

Por ejemplo, supongamos que definimos en el diccionario de datos:

`total factura = no puede contener valores nulos`

se calcula como ∑ (DETALLE FACTURAS.precio unitario * DETALLE FACTURAS.cantidad)

entonces, en la miniespecificación, bastaría con la siguiente sentencia:

`Obtener total factura(c)`

donde con (c) estoy indicando que la fórmula para calcularlo está en el diccionario de datos.

### *Conclusiones:*

La principal atracción de construir siempre una miniespecificación en una forma procedural con lenguaje estructurado es que, gracias a su gramática y vocabulario reducido y a su naturaleza “paso por paso“, brinda al analista la oportunidad de expresar con bastante exactitud lo que debe realizar cada evento para producir su respuesta, y por lo tanto verificable.

La segunda atracción está en que como el lenguaje estructurado tiene sus raíces en los lenguajes de programación estructurada, podría llegar a mplementarse fácilmente, si es que el sistema se va a implementar realmente con un lenguaje es esas características. Por lo tanto, onstruir miniespecificaciones de esta manera simplifica la generación de código.

No obstante, no debemos olvidar que la miniespecificación NO ES UN PROGRAMA, y que el lenguaje estructurado mal empleado puede llegar a ser peor que el lenguaje natural.

Es importante que en una miniespecificación en lenguaje estructurado se respeten las jerarquías de las sentencias empleando sangría, tal como se hizo con todos los ejemplos hasta ahora citados.

Otra forma de facilitar la lectura de una miniespecificación es emplear diagramas de acción, empleados por Martin & McClure. Para ello, hemos transcripto miniespecificaciones de ejemplos anteriores, para que pueda compararse:

Evento 25 - Mostrar estadística presupuestos
```
COMIENZO
  Aceptar rango de meses
  v.total del mes = 0
  Seleccionar número presupuesto de PRESUPUESTOS
    donde fecha presupuesto corresponda entre (mes desde, mes hasta) y estado = “aceptado”
    ordenado por MES(fecha presupuesto), con corte por MES(fecha presupuesto)
    Seleccionar SUMATORIA(precio presupuesto) de DETALLES PRESUPUESTO
      donde número presupuesto = PRESUPUESTOS.número presupuesto
      v.total del mes = v.total del mes + SUMATORIA(precio presupuesto)
    Fin-seleccionar
    Por cada corte de MES(fecha presupuesto), hacer:
      estadística presupuesto.mes = MES(fecha presupuesto)
      estadística presupuesto.total del mes = v.total del mes
      v.total del mes = 0
    Fin-cada-corte
  Fin-seleccionar
  estadística presupuesto.mes desde = rango de meses.mes desde
  estadística presupuesto.mes hasta = rango de meses.mes hasta
  Mostrar estadística presupuesto
FIN
```

La flecha está indicando el fin de la miniespecificación.

## Pre-condición y post-condición (no procedural):

Un problema, y muy grave del empleo del lenguaje estructurado, es que, al parecerse tanto a un lenguaje de programación, existe el peligro de que el analista preste más atención en construir una solución inteligente sin pensar lo suficiente en el problema. Muchas veces se complica la vida en explicitar la forma adecuada de acceder a los datos de un almacén en vez de reflejar los verdaderos requerimientos del sistema.

Lamentablemente, el uso de herramientas CASE refuerza esta actitud.

El uso de pre y post condición permite al analista enfocar su atención que qué es lo que debe hacer un evento en vez de las distintas maneras en que lo puede hacer.

¿Qué pasaría si a un analista se le pidiera que construya la miniespecificación de un evento que calcula la raíz cuadrada de un número?

Como sabemos, existen muchas formas de calcular la raíz cuadrada de un número: usando tablas logarítmicas; aplicando series matemáticas, ..., etc. Es más, bastaría con recurrir a una simple calculadora. 

Lo importante es entender qué significa “calcular la raíz cuadrada”. Una cosa es decidir entre la mejor forma de implementar la solución (el uso de la calculadora sería un extremo), y otra, estar seguros de que realmente entendemos bien el problema. El uso de pre y post condición puede ayudar de la siguiente manera:

Evento x – Calcular la raíz cuadrada
```
COMIENZO
  Pre-condición 1: ocurre raíz a calcular y número es >= 0
  Post-condición 1: obtener la raíz cuadrada de número e incluirla en raíz calculada
FIN
```

siendo los flujos:

`raíz a calcular = número`

`raíz calculada = número + raíz`

Pre y post condición siempre constituyen un par, y puede haber muchos pares, generalmente uno o dos pares para las situaciones normales, correspondiendo el resto a errores o excepciones. Atención: esto no es una regla. Para completar el ejemplo de la raíz cuadrada, sería necesario miniespecificar el caso de que ingrese un número negativo, por lo que quedaría de la siguiente manera:

Evento x – Calcular la raíz cuadrada
```
COMIENZO
  Pre-condición 1: ocurre raíz a calcular y número es >= 0
  Post-condición 1: obtener la raíz cuadrada de número;
    mostrar raíz calculada con número y la raíz cuadrada de número
  Pre-condición 2: ocurre raíz a calcular y número es < 0
  Post-condición 2: mostrar raíz cuadrada con “el número es negativo”
FIN
```
siendo los flujos:

`raíz a calcular = número`

`raíz calculada = número + [raíz | mensaje]`

y mensaje = “el número es negativo”

Una pre-condición representa una “fotografía” de los flujos de entrada y también, si es necesario, de los almacenes internos y/o externos antes de que el evento comience a elaborar la respuesta; mientras que la post-condición representa una “fotografía” de los flujos de salida y también, si es necesario, de los almacenes internos y/o externos luego de que el evento haya terminado de elaborar la respuesta. Nada dice sobre el comportamiento del evento: sobre cómo elaboró la respuesta: para ello sería necesario una “película” en vez de una “fotografía”. Es por ellos que algunos autores dicen que con pre y post condición se construyen miniespecificaciones “externas”, mientras que con lenguaje estructurado, se construyen miniespecificaciones “internas”.

Las sentencias a emplear dentro de cada una de las condiciones están inspiradas en un lenguaje estructurado muy simplificado, dentro de lo posible en voz pasiva. La principal diferencia está en las sentencias empleadas para indicar la ocurrencia del evento: en lenguaje estructurado se emplea Aceptar flujoentrada, mientas que aquí, como se verá en los ejemplos, se emplea la construcción Ocurre flujo-entrada.

Por supuesto, no todos los eventos son tan simples como el de calcular la raíz cuadrada de un número, veamos cómo quedan algunos de los ejemplos ya desarrollados en lenguaje estructurado, si lo hubiéramos hecho con pre y post condición.

**Ejemplo 1:**
Supongamos los siguientes almacenes:

`PRESUPUESTOS = número presupuesto + fecha presupuesto + número cliente + fecha vencimiento + estado`

`DETALLES PRESUPUESTO = número presupuesto + código artículo + cantidad + precio presupuestado`

`CONDICIONES PRESUPUESTO = número presupuesto + cantidad días + interés presupuesto`

`CLIENTES = número cliente + nombre completo + domicilio completo + situación tributaria + CUIT`

Donde:

`interés presupuesto = `
- puede tomar valores nulos, negativos y positivos;
- si es negativo significa un descuento sobre el precio presupuestado
- si es positivo significa un recargo sobre el precio presupuestado

Y el siguiente DFD para el evento: Se desea obtener estadística de presupuestos aceptados

*Figura 313*

donde:

`rango de meses = mes desde + mes hasta`

`estadística presupuesto = mes desde + mes hasta + 1{mes + total del mes}n`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 25 - Mostrar estadística presupuestos
```
COMIENZO
  Pre-condición 1: ocurre rango de meses
  Post-condición 1: mostrar estadística presupuesto con:
    mes = mes comprendido entre (mes desde, mes hasta) y
    total del mes = SUMATORIA(precio presupuesto) de DETALLES
    PRESUPUESTO para todos los PRESUPUESTOS con estado = “aceptado” y fecha comprendida entre (mes desde y mes hasta) para cada mes.
FIN
```

O bien, si hubiéramos usado el diccionario de elementos continuos para documentar cómo obtener total del mes:

Evento 25 - Mostrar estadística presupuestos
```
COMIENZO
  Pre-condición 1: ocurre rango de meses
  Post-condición 1: mostrar estadística presupuesto con:
    mes = mes comprendido entre (mes desde, mes hasta) y total del mes(c)
FIN
```
donde, en el diccionario de datos de elementos continuos definimos:

`total del mes = puede tomar valores 0` 
se calcula como: SUMATORIA(precio presupuesto) de DETALLES PRESUPUESTO
para todos los PRESUPUESTOS con estado = “aceptado” y fecha entre (mes desde, mes hasta), para cada mes.

**Ejemplo 2:**
Supongamos los siguientes almacenes:

`CTA. CTE. PROVEEDORES = número proveedor + fecha movimiento + código comprobante + número comprobante + importe débito + importe crédito`

`PROVEEDORES = número proveedor + nombre completo + domicilio completo + situación tributaria + CUITA + contacto comercial`

Y el siguiente DFD del evento: Se desea conocer el saldo de la cuenta corriente de un proveedor

*Figura 314*

donde:

`proveedor = número proveedor`

`saldo cuenta corriente = número proveedor + nombre completo + domicilio completo + saldo + cantidad movimientos + menor fecha en cta.cte.`

Podríamos construir la miniespecificación de la siguiente manera:

Evento 8 - Obtener saldo del proveedor
```
COMIENZO
  Pre-1: ocurre proveedor
  Pre-2: mostrar saldo cuenta corriente con:
    número proveedor, nombre completo y domicilio completo de PROVEEDORES;
    cantidad movimientos = CANTIDAD(ocurrencias) de CTA.CTE.PROVEEDORES;
    menor fecha en cta.cte. = MÍNIMA(fecha movimiento) de CTA.CTE.PROVEEDORES;
    saldo = SUMATORIA(importe crédito – importe débito) de CTA.CTE.PROVEEDORES para ese proveedor.número proveedor
FIN
```

O bien, si se hubiera usado diccionario de datos de elementos continuos:

Evento 8 - Obtener saldo del proveedor
```
COMIENZO
  Pre-1: ocurre proveedor
  Pre-2: mostrar saldo cuenta corriente con:
    número proveedor, nombre completo y domicilio completo de PROVEEDORES;
    cantidad movimientos(c); menor fecha en cta.cte(c) y saldo(c) para ese proveedor.número proveedor
FIN
```
siendo el diccionario de datos de estos elementos continuos:

`cantidad movimientos = puede tomar valores 0` se calcula como: CANTIDAD(ocurrencias) de CTA.CTE.PROVEEDORES

`menor fecha en cta.cte = puede tomar valores 0` se calcula como: MÍNIMA(fecha movimiento) de CTA.CTE.PROVEEDORES

`saldo = puede tomar valores 0` se calcula como: SUMATORIA(importe crédito – importe débito) de CTA.CTE.PROVEEDORES

**Ejemplo 3:**


## Tablas de decisión (gráficas):

### *¿Cómo construir una tabla de decisión?*: